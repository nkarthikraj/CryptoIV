// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PROPERTYTREE_MYPROPERTYTREE_H_
#define FLATBUFFERS_GENERATED_PROPERTYTREE_MYPROPERTYTREE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

namespace MyPropertyTree {

struct Property;
struct PropertyBuilder;

struct SubProperty;
struct SubPropertyBuilder;

enum Type : int8_t {
  Type_X = 1,
  Type_V = 2,
  Type_Y = 3,
  Type_MIN = Type_X,
  Type_MAX = Type_Y
};

inline const Type (&EnumValuesType())[3] {
  static const Type values[] = {
    Type_X,
    Type_V,
    Type_Y
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[4] = {
    "X",
    "V",
    "Y",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (::flatbuffers::IsOutRange(e, Type_X, Type_Y)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(Type_X);
  return EnumNamesType()[index];
}

struct Property FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PropertyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE = 6,
    VT_TYPE = 8,
    VT_SUBPROP = 10
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  ::flatbuffers::String *mutable_value() {
    return GetPointer<::flatbuffers::String *>(VT_VALUE);
  }
  MyPropertyTree::Type type() const {
    return static_cast<MyPropertyTree::Type>(GetField<int8_t>(VT_TYPE, 1));
  }
  bool mutate_type(MyPropertyTree::Type _type = static_cast<MyPropertyTree::Type>(1)) {
    return SetField<int8_t>(VT_TYPE, static_cast<int8_t>(_type), 1);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<MyPropertyTree::SubProperty>> *subprop() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MyPropertyTree::SubProperty>> *>(VT_SUBPROP);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<MyPropertyTree::SubProperty>> *mutable_subprop() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<MyPropertyTree::SubProperty>> *>(VT_SUBPROP);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_SUBPROP) &&
           verifier.VerifyVector(subprop()) &&
           verifier.VerifyVectorOfTables(subprop()) &&
           verifier.EndTable();
  }
};

struct PropertyBuilder {
  typedef Property Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Property::VT_NAME, name);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(Property::VT_VALUE, value);
  }
  void add_type(MyPropertyTree::Type type) {
    fbb_.AddElement<int8_t>(Property::VT_TYPE, static_cast<int8_t>(type), 1);
  }
  void add_subprop(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MyPropertyTree::SubProperty>>> subprop) {
    fbb_.AddOffset(Property::VT_SUBPROP, subprop);
  }
  explicit PropertyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Property> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Property>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Property> CreateProperty(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0,
    MyPropertyTree::Type type = MyPropertyTree::Type_X,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MyPropertyTree::SubProperty>>> subprop = 0) {
  PropertyBuilder builder_(_fbb);
  builder_.add_subprop(subprop);
  builder_.add_value(value);
  builder_.add_name(name);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Property> CreatePropertyDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *value = nullptr,
    MyPropertyTree::Type type = MyPropertyTree::Type_X,
    const std::vector<::flatbuffers::Offset<MyPropertyTree::SubProperty>> *subprop = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  auto subprop__ = subprop ? _fbb.CreateVector<::flatbuffers::Offset<MyPropertyTree::SubProperty>>(*subprop) : 0;
  return MyPropertyTree::CreateProperty(
      _fbb,
      name__,
      value__,
      type,
      subprop__);
}

struct SubProperty FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SubPropertyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA1 = 4,
    VT_DATA2 = 6
  };
  const ::flatbuffers::String *data1() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATA1);
  }
  ::flatbuffers::String *mutable_data1() {
    return GetPointer<::flatbuffers::String *>(VT_DATA1);
  }
  int16_t data2() const {
    return GetField<int16_t>(VT_DATA2, 0);
  }
  bool mutate_data2(int16_t _data2 = 0) {
    return SetField<int16_t>(VT_DATA2, _data2, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA1) &&
           verifier.VerifyString(data1()) &&
           VerifyField<int16_t>(verifier, VT_DATA2, 2) &&
           verifier.EndTable();
  }
};

struct SubPropertyBuilder {
  typedef SubProperty Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data1(::flatbuffers::Offset<::flatbuffers::String> data1) {
    fbb_.AddOffset(SubProperty::VT_DATA1, data1);
  }
  void add_data2(int16_t data2) {
    fbb_.AddElement<int16_t>(SubProperty::VT_DATA2, data2, 0);
  }
  explicit SubPropertyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SubProperty> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SubProperty>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SubProperty> CreateSubProperty(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> data1 = 0,
    int16_t data2 = 0) {
  SubPropertyBuilder builder_(_fbb);
  builder_.add_data1(data1);
  builder_.add_data2(data2);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SubProperty> CreateSubPropertyDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *data1 = nullptr,
    int16_t data2 = 0) {
  auto data1__ = data1 ? _fbb.CreateString(data1) : 0;
  return MyPropertyTree::CreateSubProperty(
      _fbb,
      data1__,
      data2);
}

inline const MyPropertyTree::Property *GetProperty(const void *buf) {
  return ::flatbuffers::GetRoot<MyPropertyTree::Property>(buf);
}

inline const MyPropertyTree::Property *GetSizePrefixedProperty(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<MyPropertyTree::Property>(buf);
}

inline Property *GetMutableProperty(void *buf) {
  return ::flatbuffers::GetMutableRoot<Property>(buf);
}

inline MyPropertyTree::Property *GetMutableSizePrefixedProperty(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<MyPropertyTree::Property>(buf);
}

inline bool VerifyPropertyBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MyPropertyTree::Property>(nullptr);
}

inline bool VerifySizePrefixedPropertyBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MyPropertyTree::Property>(nullptr);
}

inline const char *PropertyExtension() {
  return "bfbs";
}

inline void FinishPropertyBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MyPropertyTree::Property> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPropertyBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MyPropertyTree::Property> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace MyPropertyTree

#endif  // FLATBUFFERS_GENERATED_PROPERTYTREE_MYPROPERTYTREE_H_
